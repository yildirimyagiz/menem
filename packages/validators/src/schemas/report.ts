import { z } from "zod";

// Define ReportStatus and ReportType locally since imports are not working
const ReportStatus = {
  GENERATED: "GENERATED" as const,
  IN_PROGRESS: "IN_PROGRESS" as const,
  COMPLETED: "COMPLETED" as const,
  FAILED: "FAILED" as const,
  ARCHIVED: "ARCHIVED" as const,
} as const;

const ReportType = {
  FINANCIAL: "FINANCIAL" as const,
  PERFORMANCE: "PERFORMANCE" as const,
  COMPLIANCE: "COMPLIANCE" as const,
  MARKET_ANALYSIS: "MARKET_ANALYSIS" as const,
  REVENUE: "REVENUE" as const,
  OCCUPANCY: "OCCUPANCY" as const,
  GUEST_ANALYSIS: "GUEST_ANALYSIS" as const,
  OFFER_PERFORMANCE: "OFFER_PERFORMANCE" as const,
  RESERVATION_SUMMARY: "RESERVATION_SUMMARY" as const,
  EXPENSE_TRACKING: "EXPENSE_TRACKING" as const,
  TASK_MANAGEMENT: "TASK_MANAGEMENT" as const,
  PROPERTY_PERFORMANCE: "PROPERTY_PERFORMANCE" as const,
} as const;

type ReportStatus = typeof ReportStatus[keyof typeof ReportStatus];
type ReportType = typeof ReportType[keyof typeof ReportType];

// Export enums for frontend use
export { ReportStatus, ReportType };

// Report Schema with improved validation
export const ReportSchema = z
  .object({
    id: z.string().optional(),
    title: z.string().min(1, "Title is required").max(255, "Title too long"),
    reportType: z.nativeEnum(ReportType),
    generatedById: z.string().min(1, "Generated by ID is required"),
    startDate: z.date({
      required_error: "Start date is required",
      invalid_type_error: "Start date must be a valid date",
    }),
    endDate: z.date({
      required_error: "End date is required",
      invalid_type_error: "End date must be a valid date",
    }),
    entityId: z.string().optional().nullable(),
    entityType: z
      .string()
      .max(100, "Entity type too long")
      .optional()
      .nullable(),
    totalRevenue: z
      .number()
      .nonnegative("Revenue cannot be negative")
      .optional()
      .nullable(),
    totalBookings: z
      .number()
      .int()
      .nonnegative("Bookings cannot be negative")
      .optional()
      .nullable(),
    averagePrice: z
      .number()
      .nonnegative("Average price cannot be negative")
      .optional()
      .nullable(),
    occupancyRate: z
      .number()
      .min(0, "Occupancy rate must be between 0 and 100")
      .max(100, "Occupancy rate must be between 0 and 100")
      .optional()
      .nullable(),
    fileUrl: z.string().url("Invalid file URL").optional().nullable(),
    description: z
      .string()
      .max(1000, "Description too long")
      .optional()
      .nullable(),
    data: z.any().optional().nullable(),
    status: z.nativeEnum(ReportStatus).default(ReportStatus.GENERATED),
    createdAt: z.date().default(() => new Date()),
    updatedAt: z.date().default(() => new Date()),
    deletedAt: z.date().nullable().optional(),
    agencyId: z.string().optional().nullable(),
    facilityId: z.string().optional().nullable(),
    includedServiceId: z.string().optional().nullable(),
    extraChargeId: z.string().optional().nullable(),
    providerId: z.string().optional().nullable(),
    propertyId: z.string().optional().nullable(),
    tenantId: z.string().optional().nullable(),
    agentId: z.string().optional().nullable(),
    reservationIds: z
      .array(z.string().min(1, "Invalid reservation ID"))
      .default([]),
    totalReservations: z
      .number()
      .int()
      .nonnegative("Total reservations cannot be negative")
      .optional()
      .nullable(),
    cancelledReservations: z
      .number()
      .int()
      .nonnegative("Cancelled reservations cannot be negative")
      .optional()
      .nullable(),
    completedReservations: z
      .number()
      .int()
      .nonnegative("Completed reservations cannot be negative")
      .optional()
      .nullable(),
    averageReservationLength: z
      .number()
      .nonnegative("Average reservation length cannot be negative")
      .optional()
      .nullable(),
    totalPaidReservations: z
      .number()
      .nonnegative("Total paid reservations cannot be negative")
      .optional()
      .nullable(),
    totalUnpaidReservations: z
      .number()
      .nonnegative("Total unpaid reservations cannot be negative")
      .optional()
      .nullable(),

    // Relations
    Agency: z.any().optional().nullable(),
    Facility: z.any().optional().nullable(),
    IncludedService: z.any().optional().nullable(),
    ExtraCharge: z.any().optional().nullable(),
    Provider: z.any().optional().nullable(),
    Property: z.any().optional().nullable(),
    Tenant: z.any().optional().nullable(),
    Agent: z.any().optional().nullable(),
    Reservation: z.any().optional(),
    generatedBy: z.any().optional().nullable(),
  })
  .refine(
    (data) => {
      if (data.startDate && data.endDate) {
        return data.startDate <= data.endDate;
      }
      return true;
    },
    {
      message: "End date must be after start date",
      path: ["endDate"],
    },
  );

// Create Report Schema with validation
export const CreateReportSchema = z
  .object({
    title: z.string().min(1, "Title is required").max(255, "Title too long"),
    reportType: z.nativeEnum(ReportType),
    generatedById: z.string().min(1, "Generated by ID is required"),
    startDate: z.date({
      required_error: "Start date is required",
      invalid_type_error: "Start date must be a valid date",
    }),
    endDate: z.date({
      required_error: "End date is required",
      invalid_type_error: "End date must be a valid date",
    }),
    entityId: z.string().optional().nullable(),
    entityType: z
      .string()
      .max(100, "Entity type too long")
      .optional()
      .nullable(),
    description: z
      .string()
      .max(1000, "Description too long")
      .optional()
      .nullable(),
    agencyId: z.string().optional().nullable(),
    facilityId: z.string().optional().nullable(),
    includedServiceId: z.string().optional().nullable(),
    extraChargeId: z.string().optional().nullable(),
    providerId: z.string().optional().nullable(),
    propertyId: z.string().optional().nullable(),
    tenantId: z.string().optional().nullable(),
    agentId: z.string().optional().nullable(),
    reservationIds: z
      .array(z.string().min(1, "Invalid reservation ID"))
      .default([]),
  })
  .refine(
    (data: { startDate: Date; endDate: Date }) => {
      if (data.startDate && data.endDate) {
        return data.startDate <= data.endDate;
      }
      return true;
    },
    {
      message: "End date must be after start date",
      path: ["endDate"],
    },
  );

// Update Report Schema
export const UpdateReportSchema = z
  .object({
    id: z.string().min(1, "Report ID is required"),
    title: z
      .string()
      .min(1, "Title is required")
      .max(255, "Title too long")
      .optional(),
    reportType: z.nativeEnum(ReportType).optional(),
    generatedById: z.string().min(1, "Generated by ID is required").optional(),
    startDate: z
      .date({
        required_error: "Start date is required",
        invalid_type_error: "Start date must be a valid date",
      })
      .optional(),
    endDate: z
      .date({
        required_error: "End date is required",
        invalid_type_error: "End date must be a valid date",
      })
      .optional(),
    entityId: z.string().optional().nullable(),
    entityType: z
      .string()
      .max(100, "Entity type too long")
      .optional()
      .nullable(),
    description: z
      .string()
      .max(1000, "Description too long")
      .optional()
      .nullable(),
    agencyId: z.string().optional().nullable(),
    facilityId: z.string().optional().nullable(),
    includedServiceId: z.string().optional().nullable(),
    extraChargeId: z.string().optional().nullable(),
    providerId: z.string().optional().nullable(),
    propertyId: z.string().optional().nullable(),
    tenantId: z.string().optional().nullable(),
    agentId: z.string().optional().nullable(),
    reservationIds: z
      .array(z.string().min(1, "Invalid reservation ID"))
      .optional(),
    status: z.nativeEnum(ReportStatus).optional(),
  })
  .refine(
    (data: { startDate?: Date; endDate?: Date }) => {
      if (data.startDate && data.endDate) {
        return data.startDate <= data.endDate;
      }
      return true;
    },
    {
      message: "End date must be after start date",
      path: ["endDate"],
    },
  );

// Report Filter Schema with improved validation
export const ReportFilterSchema = z
  .object({
    title: z.string().optional(),
    reportType: z.nativeEnum(ReportType).optional(),
    generatedById: z.string().min(1, "Generated by ID is required").optional(),
    startDateFrom: z.date().optional(),
    startDateTo: z.date().optional(),
    endDateFrom: z.date().optional(),
    endDateTo: z.date().optional(),
    status: z.nativeEnum(ReportStatus).optional(),
    agencyId: z.string().optional().nullable(),
    facilityId: z.string().optional().nullable(),
    includedServiceId: z.string().optional().nullable(),
    extraChargeId: z.string().optional().nullable(),
    providerId: z.string().optional().nullable(),
    propertyId: z.string().optional().nullable(),
    tenantId: z.string().optional().nullable(),
    agentId: z.string().optional().nullable(),
    totalRevenueFrom: z
      .number()
      .nonnegative("Revenue from cannot be negative")
      .optional(),
    totalRevenueTo: z
      .number()
      .nonnegative("Revenue to cannot be negative")
      .optional(),
    totalBookingsFrom: z
      .number()
      .int()
      .nonnegative("Bookings from cannot be negative")
      .optional(),
    totalBookingsTo: z
      .number()
      .int()
      .nonnegative("Bookings to cannot be negative")
      .optional(),
    page: z
      .number()
      .int()
      .min(1, "Page must be at least 1")
      .optional()
      .default(1),
    pageSize: z
      .number()
      .int()
      .min(1, "Page size must be at least 1")
      .max(100, "Page size cannot exceed 100")
      .optional()
      .default(10),
    sortBy: z
      .enum([
        "createdAt",
        "updatedAt",
        "startDate",
        "endDate",
        "status",
        "title",
        "reportType",
      ])
      .optional()
      .default("createdAt"),
    sortOrder: z.enum(["asc", "desc"]).optional().default("desc"),
    includeDeleted: z.boolean().optional().default(false),
  })
  .refine(
    (data) => {
      if (
        data.startDateFrom &&
        data.startDateTo &&
        data.startDateFrom > data.startDateTo
      ) {
        return false;
      }
      if (
        data.endDateFrom &&
        data.endDateTo &&
        data.endDateFrom > data.endDateTo
      ) {
        return false;
      }
      if (
        data.totalRevenueFrom &&
        data.totalRevenueTo &&
        data.totalRevenueFrom > data.totalRevenueTo
      ) {
        return false;
      }
      if (
        data.totalBookingsFrom &&
        data.totalBookingsTo &&
        data.totalBookingsFrom > data.totalBookingsTo
      ) {
        return false;
      }
      return true;
    },
    {
      message: "Invalid date or number range",
    },
  );

// Bulk operations schema
export const BulkReportOperationSchema = z.object({
  reportIds: z
    .array(z.string().min(1, "Invalid report ID"))
    .min(1, "At least one report ID is required"),
  operation: z.enum(["delete", "download", "regenerate"]),
});

// Report generation schema
export const GenerateReportSchema = z
  .object({
    title: z.string().min(1, "Title is required").max(255, "Title too long"),
    reportType: z.nativeEnum(ReportType),
    startDate: z.date({
      required_error: "Start date is required",
      invalid_type_error: "Start date must be a valid date",
    }),
    endDate: z.date({
      required_error: "End date is required",
      invalid_type_error: "End date must be a valid date",
    }),
    format: z.enum(["PDF", "CSV", "EXCEL"]).default("PDF"),
    filters: z
      .object({
        agencyId: z.string().optional(),
        facilityId: z.string().optional(),
        propertyId: z.string().optional(),
        tenantId: z.string().optional(),
        agentId: z.string().optional(),
        status: z.string().optional(),
        entityType: z.string().optional(),
      })
      .optional(),
  })
  .refine((data) => data.startDate <= data.endDate, {
    message: "End date must be after start date",
    path: ["endDate"],
  });

// Zod Type Inference for TypeScript
export type Report = z.infer<typeof ReportSchema>;
export type CreateReportInput = z.infer<typeof CreateReportSchema>;
export type UpdateReportInput = z.infer<typeof UpdateReportSchema>;
export type ReportFilterInput = z.infer<typeof ReportFilterSchema>;
export type BulkReportOperationInput = z.infer<
  typeof BulkReportOperationSchema
>;
export type GenerateReportInput = z.infer<typeof GenerateReportSchema>;

// Helper types for API responses
export interface ReportListResponse {
  data: Report[];
  page: number;
  pageSize: number;
  total: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}

export interface ReportSummary {
  totalReports: number;
  reportsByStatus: Record<ReportStatus, number>;
  reportsByType: Record<ReportType, number>;
  totalRevenue: number;
  averageOccupancyRate: number;
}
